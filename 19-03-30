Q1:上台阶：
有一楼梯共m级，刚开始时你在第一级，若每次只能跨上一级或者二级，要走上m级，共有多少走法？注：规定从一级到一级有0种走法。

给定一个正整数int n，请返回一个数，代表上楼的方式数。保证n小于等于100。为了防止溢出，请返回结果Mod 1000000007的值。

测试样例：
3
返回：2

class GoUpstairs {
public:
    int countWays(int n) {
        vector<int> dp(100,0);
        dp[0] = 1;
        dp[1] = 1;
        if(n<2){
            return dp[n-1];
        }
        for(int i = 2;i<n;i++)
          dp[i] = (dp[i-1] + dp[i-2])%1000000007;
        return dp[n-1];
    }
};

小易经常沉迷于网络游戏.有一次,他在玩一个打怪升级的游戏,他的角色的初始能力值为 a.在接下来的一段时间内,他将会依次遇见n个怪物,每个怪物的防御力为b1,b2,b3...bn. 如果遇到的怪物防御力bi小于等于小易的当前能力值c,那么他就能轻松打败怪物,并 且使得自己的能力值增加bi;如果bi大于c,那他也能打败怪物,但他的能力值只能增加bi 与c的最大公约数.那么问题来了,在一系列的锻炼后,小易的最终能力值为多少?
输入描述:
对于每组数据,第一行是两个整数n(1≤n<100000)表示怪物的数量和a表示小易的初始能力值.
第二行n个整数,b1,b2...bn(1≤bi≤n)表示每个怪物的防御力
输出描述:
对于每组数据,输出一行.每行仅包含一个整数,表示小易的最终能力值
示例1
输入
复制
3 50
50 105 200
5 20
30 20 15 40 100
输出
复制
110
205


#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int gcd(int a,int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

int main()
{
    int n, tmpValue, tmp;
    
    vector<int> b(100000);
    while(cin >> n >> tmpValue)
    {
        for(int i=0;i<n;i++)
            cin >> b[i];
        
        for(int i = 0;i<n;i++)
        {
            if(b[i] <= tmpValue)
                tmpValue += b[i];
            else
                tmpValue += gcd(tmpValue, b[i]);
        }
        cout << tmpValue <<endl;
    }
    return 0;
}

度度熊想去商场买一顶帽子，商场里有N顶帽子，有些帽子的价格可能相同。度度熊想买一顶价格第三便宜的帽子，问第三便宜的帽子价格是多少？

输入描述:
首先输入一个正整数N（N <= 50），接下来输入N个数表示每顶帽子的价格（价格均是正整数，且小于等于1000）

输出描述:
如果存在第三便宜的帽子，请输出这个价格是多少，否则输出-1

输入例子1:
10
10 10 10 10 20 20 30 30 40 40

输出例子1:
30

#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <set>
using namespace std;
int minK(int n, set<int>& price)
{
    if(price.size()<3) return -1;
    set<int>::iterator it;
    int i=0;
    for(it=price.begin(); (it!=price.end() && i<2); it++,i++)
    {
 
    }
    return *it;
}
int main()
{
    int n,tmp;
    cin>> n;
    set<int> price;
    for(int i=0;i<n;i++)
    {
        cin >> tmp;
        price.insert(tmp);
    }
    
    cout << minK(n,price) << endl;
    return 0;
}

一个数轴上共有N个点，第一个点的坐标是度度熊现在位置，第N-1个点是度度熊的家。现在他需要依次的从0号坐标走到N-1号坐标。
但是除了0号坐标和N-1号坐标，他可以在其余的N-2个坐标中选出一个点，并直接将这个点忽略掉，问度度熊回家至少走多少距离？

#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int main()
{
    int n, a[50];
    while (cin >> n)
    {
        int i, ans = 0;
        for (i = 0; i < n; i++)
        {
            cin >> a[i];
            /* 计算两个相邻节点之间的距离，ans为所有相邻节点距离的总和 */
            if (i)
                ans += abs(a[i] - a[i - 1]);
        }
        int _m = 0;
        //计算相邻的3个节点之间的距离总和，A->B,B->C,A->C
        for (i = 0; i < n - 2; i++)
            _m = max(_m, abs(a[i] - a[i + 1]) + abs(a[i + 1] - a[i + 2]) - abs(a[i] - a[i + 2]));
        cout << ans - _m << endl;//_m属于重复计算
    }
    return 0;
}

