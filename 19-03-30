Q1:上台阶：
有一楼梯共m级，刚开始时你在第一级，若每次只能跨上一级或者二级，要走上m级，共有多少走法？注：规定从一级到一级有0种走法。

给定一个正整数int n，请返回一个数，代表上楼的方式数。保证n小于等于100。为了防止溢出，请返回结果Mod 1000000007的值。

测试样例：
3
返回：2

class GoUpstairs {
public:
    int countWays(int n) {
        vector<int> dp(100,0);
        dp[0] = 1;
        dp[1] = 1;
        if(n<2){
            return dp[n-1];
        }
        for(int i = 2;i<n;i++)
          dp[i] = (dp[i-1] + dp[i-2])%1000000007;
        return dp[n-1];
    }
};

小易经常沉迷于网络游戏.有一次,他在玩一个打怪升级的游戏,他的角色的初始能力值为 a.在接下来的一段时间内,他将会依次遇见n个怪物,每个怪物的防御力为b1,b2,b3...bn. 如果遇到的怪物防御力bi小于等于小易的当前能力值c,那么他就能轻松打败怪物,并 且使得自己的能力值增加bi;如果bi大于c,那他也能打败怪物,但他的能力值只能增加bi 与c的最大公约数.那么问题来了,在一系列的锻炼后,小易的最终能力值为多少?
输入描述:
对于每组数据,第一行是两个整数n(1≤n<100000)表示怪物的数量和a表示小易的初始能力值.
第二行n个整数,b1,b2...bn(1≤bi≤n)表示每个怪物的防御力
输出描述:
对于每组数据,输出一行.每行仅包含一个整数,表示小易的最终能力值
示例1
输入
复制
3 50
50 105 200
5 20
30 20 15 40 100
输出
复制
110
205


#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int gcd(int a,int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

int main()
{
    int n, tmpValue, tmp;
    
    vector<int> b(100000);
    while(cin >> n >> tmpValue)
    {
        for(int i=0;i<n;i++)
            cin >> b[i];
        
        for(int i = 0;i<n;i++)
        {
            if(b[i] <= tmpValue)
                tmpValue += b[i];
            else
                tmpValue += gcd(tmpValue, b[i]);
        }
        cout << tmpValue <<endl;
    }
    return 0;
}



